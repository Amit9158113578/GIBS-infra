input {
        file {
                path => "/etc/logstash/files/kpiData1.csv"
                sincedb_path => "/dev/null"
                start_position => "beginning"
        }
}
filter {
        if "KPI_name" in [message] {
                drop {}
        }
        csv {
                columns => ["KPIID","KPI_name","financial_year","Period","period_desc","category","Subcategory","data_value","previous_value"]
                skip_header => true
        }
        if [category] {
        elasticsearch {
                hosts => ["$logstash_elastic_hosts"]
                index => "gbis-gcc-master-data"
                user => "$elasticsearch_username"
                password => "$elasticsearch_password"
                ca_file => "/etc/logstash/security/ca/ca.crt"
                query => "KPIID.keyword:%{KPIID} AND category:%{category}"
                fields => {
                        "Assigned_Inst" => "Assigned_Inst"
                        "Base_Ministry" => "Base_Ministry"
                        "Cluster" => "Cluster"
                        "KPI_Desc" => "KPI_Desc"
                        "Reporting_Inst" => "Reporting_Inst"
                        "Sector" => "Sector"
                        "UOM" => "UOM"
                        "TABLE_ID" => "TABLE_ID"
                        "ID" => "ID"
                        "Metric_type" => "Metric_type"
                }
        }
        }
        else {
                elasticsearch {
                hosts => ["$logstash_elastic_hosts"]
                index => "gbis-gcc-master-data"
                user => "$elasticsearch_username"
                password => "$elasticsearch_password"
                ca_file => "/etc/logstash/security/ca/ca.crt"
                query => "KPIID.keyword:%{KPIID}"
                fields => {
                        "Assigned_Inst" => "Assigned_Inst"
                        "Base_Ministry" => "Base_Ministry"
                        "Cluster" => "Cluster"
                        "KPI_Desc" => "KPI_Desc"
                        "Reporting_Inst" => "Reporting_Inst"
                        "Sector" => "Sector"
                        "UOM" => "UOM"
                        "TABLE_ID" => "TABLE_ID"
                        "ID" => "ID"
                        "Metric_type" => "Metric_type"
                }
                }
        }
        if ![category] {
        elasticsearch {
                hosts => ["$logstash_elastic_hosts"]
                index => "gbis-gcc-target-data"
                user => "$elasticsearch_username"
                password => "$elasticsearch_password"
                ca_file => "/etc/logstash/security/ca/ca.crt"
                query => "KPIID.keyword:%{KPIID} AND Period.keyword:%{Period} AND financial_year.keyword:%{financial_year} AND period_desc.keyword:%{period_desc}"
                fields => {
                        "Target_value" => "Target_value"
                }
        }
        }
        else {
        elasticsearch {
                hosts => ["$logstash_elastic_hosts"]
                index => "gbis-gcc-target-data"
                user => "$elasticsearch_username"
                password => "$elasticsearch_password"
                ca_file => "/etc/logstash/security/ca/ca.crt"
                query => "KPIID.keyword:%{KPIID} AND Period.keyword:%{Period} AND financial_year.keyword:%{financial_year} AND period_desc.keyword:%{period_desc} AND category:%{category}"
                fields => {
                        "Target_value" => "Target_value"
                }
        }
        }
        mutate {
                convert => { "data_value" => "float" }
                convert => { "Target_value" => "float" }
                convert => { "previous_value" => "float" }
        }
        if "Yearly" in [Period] {
                mutate {
                        add_field => { "Month" => "NA" }
                        add_field => { "Quarter" => "NA" }
                }
        }
        else if "Quarterly" in [Period] {
                mutate {
                        add_field => { "Month" => "NA" }
                        add_field => { "Quarter" => "%{period_desc}" }
                }
        }
        else if "Monthly" in [Period] {
                 mutate {
                        add_field => { "Month" => "%{period_desc}" }
                }
                if "April" in [period_desc] or "May" in [period_desc] or "June" in [period_desc] {
                        mutate {
                                add_field => { "Quarter" => "Q4" }
                        }
                }
                else if "July" in [period_desc] or "August" in [period_desc] or "September" in [period_desc] {
                        mutate {
                                add_field => { "Quarter" => "Q1" }
                        }
                }
                else  if "October" in [period_desc] or "November" in [period_desc] or "December" in [period_desc] {
                        mutate {
                                add_field => { "Quarter" => "Q2" }
                        }
                }
                else if "January" in [period_desc] or "February" in [period_desc] or "March" in [period_desc] {
                        mutate {
                                add_field => { "Quarter" => "Q3" }
                        }
                }
                else {
                        mutate {
                                add_field => { "Quarter" => "NA" }
                        }
                }
        }
        else {
                mutate {
                        add_field => { "Month" => "NA" }
                        add_field => { "Quarter" => "NA" }
                }
        }
        translate {
                field => "period_desc"
                destination => "sort_order"
                fallback => "NA"
                dictionary_path => "/etc/logstash/files/sort_file.csv"
        }
        if [Target_value] and [Target_value] > 0 and "Higher" in [Metric_type] {
                ruby {
                        code => "event.set('completion', (event.get('data_value').to_f / event.get('Target_value').to_f) * 100)"
                }
        }
        if [Target_value] and [Target_value] > 0 and "Lower" in [Metric_type] and [previous_value] > 0 {
                ruby {
                        code => "event.set('completion', ((event.get('previous_value').to_f - event.get('data_value').to_f) / (event.get('previous_value').to_f - event.get('Target_value').to_f)) * 100)"
                }
        }
        grok {
                match => { "financial_year" => "%{DATA}-%{WORD:new_sort}" }
        }
        mutate {
                convert => { "sort_order" => "integer" }
                convert => { "new_sort" => "integer" }
                convert => { "completion" => "float" }
        }
        if [completion] {
        if [completion] > 100 {
                mutate {
                        add_field => { "kpi_status" => "Over Achieved" }
                }
        }
        else if [completion] < 100 {
                mutate {
                        add_field => { "kpi_status" => "Work In Progress" }
                }
        }
        else {
                mutate {
                        add_field => { "kpi_status" => "Achieved" }
                }
        }
        }
        else {
                mutate {
                        add_field => { "kpi_status" => "Target Data not uploaded" }
                }
        }
}
output {
        stdout {
                codec => "rubydebug"
        }
        elasticsearch {
                hosts => ["$logstash_elastic_hosts"]
                index => "gbis-gcc-kpi-data"
                user => "$elasticsearch_username"
                password => "$elasticsearch_password"
                ssl => true
                ssl_certificate_verification => true
                cacert => "/etc/logstash/security/ca/ca.crt"
        }
}